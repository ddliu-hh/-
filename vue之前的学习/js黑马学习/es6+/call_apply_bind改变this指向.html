<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <!-- 
    JavaScript 中还允许指定函数中 this 的指向，有3个方法可以动态指定普通函数中this的指向
call()
apply()
bind()

   -->
</head>

<body>
  <!-- 1.call -->
  <script>
    const obj1 = {
      uname: 'pink'
    }
    function fn1(x, y) {
      console.log(this) // window
      console.log(x + y)
    }
    // 1. 调用函数  
    // 2. 改变 this 指向
    //     fun.call(thisArg, arg1 , arg2,...)
    // thisArg:在fun函数运行时指定的this值
    // arg1, arg2:传递进函数的参数，比如fn这个函数需要两个实参，就填两个
    // 返回值就是函数的返回值，因为它就是调用函数
    fn1.call(obj1, 1, 2)
  </script>

  <!-- 2.apply -->
  <script>
    // apply语法：
    //     fun.apply(thisArg, [argsArray])
    // thisArg:在fun函数运行时指定的 this值
    // argsArray:传递的值，必须包含在数组里面返回值就是函数的返回值，因为它就是调用函数
    // 因此 apply主要跟数组有关系，比如使用Math.max()求数组的最大值

    const obj2 = {
      age: 18
    }
    function fn(x, y) {
      console.log(this) // {age: 18}
      console.log(x + y)
    }
    // 1. 调用函数
    // 2. 改变this指向 
    //  fn.apply(this指向谁, 数组参数)
    fn.apply(obj2, [1, 2])
    // 3. 返回值 : 本身就是在调用函数，所以返回值就是函数的返回值

    // 使用场景： 求数组最大值
    // const max = Math.max(1, 2, 3)
    // console.log(max)
    //原理是将数组 arr 的元素作为参数传递给 Math.max() 函数。这会导致 Math.max() 函数将数组中的元素作为单独的参数来比较并返回最大值。
    const arr = [100, 44, 77]
    const max = Math.max.apply(Math, arr)//比展开运算符好一点
    const min = Math.min.apply(null, arr)
    console.log(max, min)
    // 使用场景： 求数组最大值
    console.log(Math.max(...arr))
  </script>



  <button>发送短信</button>
  <!-- 
  与前两种不同之处是bind()方法不会调用函数。但是能改变函数内部this指向语法:
fun.bind (thisArg, arg1, arg2, ...)
thisArg:在fun函数运行时指定的this值
心
arg1,arg2:传递的其他参数
返回由指定的this值和初始化参数改造的原函数拷贝（新函数)
 -->
  <script>
    const obj = {
      age: 18
    }
    function fn() {
      console.log(this)
    }

    // 1. 返回值是个函数，  但是这个函数里面的this是更改过的obj
    const fun = fn.bind(obj)
    // console.log(fun) 
    fun()

    // 需求，有一个按钮，点击里面就禁用，2秒钟之后开启
    document.querySelector('button').addEventListener('click', function () {
      // 禁用按钮
      this.disabled = true
      window.setTimeout(function () {
        // 在这个普通函数里面，我们要this由原来的window 改为 btn
        this.disabled = false
      }.bind(this), 2000)   // 这里的this 和 btn 一样
    })
  </script>
</body>

</html>